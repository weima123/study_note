## 一.redis支持的数据类型
### 1.string--字符串
### 2.list--列表
### 3.hash--字典
### 4.set--集合
### 5.sorted_set--有序集合

## 二.redis线程模型
### 1.单线程

### 三.redis快的原因
### 1.纯内存操作 
### 2.io多路复用 （就是一个线程监听多个套接字，谁先有读写事件就处理谁，减少线程切换开销和IO阻塞，以提高CPU利用率）
### 3.单线程减少了线程上下文切换的开销

## 四.redis缓存过期策略
### 1.redis设置过期时间

#### 1)expire(String key,long time) [默认时间为秒]
#### 2)setex(String key,long time, String value) [默认时间为秒][字符串独有的失效时间设置方式]
```
warn:
1.除了字符串可以通过setex指令设置过期时间，其他结构的数据都只能用expire来设置过期时间
2.若数据果没有设置过期时间，则数据永远不过期
3.若数据设置了过期时间，又想改为永不过期可以通过
```
### 2.redis过期策略
#### 1.定期删除
```
redis每隔100ms随机抽取一部分设置了过期时间的缓存，检查是否过期，如果已过期就删除
```
#### 2.惰性策略
```
定期删除可能导致一部分缓存到了过期时间仍未被删除，这个时候就会走惰性删除策略。即，每次查询缓存的时候判断缓存是否
过期，如果已经过期就对缓存做删除。
```
```
通过定期删除+惰性删除的策略仍然可能存在一部分缓存过期后未被删除（定期删除未删除的缓存，后面也一直未被查询，导致惰性
删除和定期删除都未能清除缓存）。
如果大量内存堆积，导致redis内存控件不足，这个时候怎么办？
答案是：走内存淘汰机制
```
#### 3.内存淘汰
```
noeviction：当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧
allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）
allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key，这个一般没人用吧
volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key（这个一般不太合适）
volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key
volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除
```


## 五.redis持久化
### 1.AOF 在redis.conf中配置，每次都会将redis数据变更的操作，追加到磁盘文件中
### 2.RDB 在redis.conf中配置触发条件，满足触发条件时，redis会自动生成redis内存快照镜像
```
warn:AOF、RDB的优缺点：
RDB可能导致某段时间内的数据丢失，但是保证了redis的性能
AOF浪费了部分redis性能，但是最大程度保证了redis数据不丢失
```
## 六.redis高可用 https://www.jianshu.com/p/7d5fbf90bcd7
### 1.主从
```
主节点负责读写，从节点负责读。
存在问题：主节点无效后，导致新的缓存数据无法写入
```
### 2.哨兵模式
```
主节点失效后，从从节点中选择一个节点代替成为主节点，并修改其他节点的配置，指向
新的主节点
主要功能：
监控：监控主、从节点的状态
通知：当监控到某个节点存在故障时，可以通过api通知到程序员
自动故障迁移：主节点失效后，从从节点中选择一个节点代替成为主节点，并修改其他节点的配置，指向
新的主节点

```
### 3.redis集群

## 七.手写LRU

## 八.redis常用场景
### 1.缓存
### 2.分布式锁
```
setNx 、expire 、watch
```
### 3.消息中间件