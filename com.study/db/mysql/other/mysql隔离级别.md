## MySQL事务隔离级别
[c-code] https://www.cnblogs.com/huanongying/p/7021555.html

|事务隔离级别|脏读|不可重复读|	幻读|
|------|-----|-----|-----|
|读未提交（read-uncommitted）|	是|	是|	是|
|不可重复读（read-committed）|	否	|是	|是|
|可重复读（repeatable-read）	|否|	否|	是|
|串行化（serializable）|	否	|否	|否|

mysql默认的事务隔离级别为repeatable-read

## 用例子说明各个隔离级别的情况
### 1.读未提交：
####（1）打开一个客户端A，并设置当前事务模式为read uncommitted（未提交读），查询表account的初始值：
####（2）在客户端A的事务提交之前，打开另一个客户端B，更新表account：
####（3）这时，虽然客户端B的事务还没提交，但是客户端A就可以查询到B已经更新的数据：
####（4）一旦客户端B的事务因为某种原因回滚，所有的操作都将会被撤销，那客户端A查询到的数据其实就是脏数据：
####（5）在客户端A执行更新语句update account set balance = balance - 50 where id =1，lilei的balance没有变成350，居然是400，是不是很奇怪，数据不一致啊，如果你这么想就太天真 了，在应用程序中，我们会用400-50=350，并不知道其他会话回滚了，要想解决这个问题可以采用读已提交的隔离级别
 
### 2、读已提交
####（1）打开一个客户端A，并设置当前事务模式为read committed（未提交读），查询表account的所有记录：
####（2）在客户端A的事务提交之前，打开另一个客户端B，更新表account：
####（3）这时，客户端B的事务还没提交，客户端A不能查询到B已经更新的数据，解决了脏读问题：
####（4）客户端B的事务提交
####（5）客户端A执行与上一步相同的查询，结果 与上一步不一致，即产生了不可重复读的问题
### 3、可重复读
####（1）打开一个客户端A，并设置当前事务模式为repeatable read，查询表account的所有记录
####（2）在客户端A的事务提交之前，打开另一个客户端B，更新表account并提交
####（3）在客户端A查询表account的所有记录，与步骤（1）查询结果一致，没有出现不可重复读的问题
####（4）在客户端A，接着执行update balance = balance - 50 where id = 1，balance没有变成400-50=350，lilei的balance值用的是步骤（2）中的350来算的，所以是300，数据的一致性倒是没有被破坏。可重复读的隔离级别下使用了MVCC机制，select操作不会更新版本号，是快照读（历史版本）；insert、update和delete会更新版本号，是当前读（当前版本）。
####（5）重新打开客户端B，插入一条新数据后提交
####（6）在客户端A查询表account的所有记录，没有 查出 新增数据，所以没有出现幻读
###4.串行化
####（1）打开一个客户端A，并设置当前事务模式为serializable，查询表account的初始值：
####　（2）打开一个客户端B，并设置当前事务模式为serializable，插入一条记录报错，表被锁了插入失败，mysql中事务隔离级别为serializable时会锁表，因此不会出现幻读的情况，这种隔离级别并发性极低，开发中很少会用到。
## 补充：
#### 1、事务隔离级别为读提交时，写数据只会锁住相应的行
#### 2、事务隔离级别为可重复读时，如果检索条件有索引（包括主键索引）的时候，默认加锁方式是next-key 锁；如果检索条件没有索引，更新数据时会锁住整张表。一个间隙被事务加了锁，其他事务是不能在这个间隙插入记录的，这样可以防止幻读。
#### 3、事务隔离级别为串行化时，读写数据都会锁住整张表
#### 4、隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。