## 一.volatile关键字作用 https://www.cnblogs.com/zhengbin/p/5654805.html
### 1.保证变量的内存可见性
```
  非volatitle修饰的变量，每次线程使用变量时都先将变量从内存拷贝到cpu缓存中；当某个线程更改变量的值的时候，如果多个线程处在不同的cpu上的时候，
 不同线程读取到的变量的值是不同的；
  对于volatitle修饰的变量，每次线程使用变量时都从主内存中读取变量的值，某个线程更改变量的值后会直接把变量的值写回到内存中；因此保证了变量对于不同线程的可见性
```

![avatar](file/volatile可见性.png)

### 2.禁止cpu重排序
1.cpu指令重排序
```
int i=0;
int flag = true;
i = 3;//语句1
flag = false;//语句2

1.对于上述两个语句，语句1一定会在语句2之前执行吗？答案是不一定，因为cpu会在执行阶段对指令做优化，cpu只保证最后执行结果的一致性，不保证
各个语句的执行顺序的一致性。

2.cpu如何保证执行结果的一致性？靠的是数据依赖性：编译器和处理器不会改变存在依赖的两个指令间的执行顺序
double i = 1;//A
double k= 2;//B
double t = i*k;//C
A和C之间存在数据依赖性，B和C之间也存在数据依赖性，因此A、B肯定都会在C之前执行

```
### 3.volatile底层原理--内存屏障

```
1.内存屏障会阻止屏障两侧的指令重排序
2.数据变更后内存屏障会强制将屏障两侧的数据写回主内存，在数据读取时内存屏障会强制读取主内存的数据
```

### 4.volatile和synchronized区别
```
1.使用方式：volatile只能修饰变量，synchronized可以用来修饰变量、方法、代码块
2.作用：volatile只保证了可见性，不保证操作的原子性；synchronized保证了变量的可见性和操作的原子性
```